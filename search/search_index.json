{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p><code>pytasks</code> is a complete and customizable microservice for running computational tasks on remote machines and viewing its results through an API. </p> <p> Notice: the documentation for this project is still being written. You may encounter uncomplete pages or sections.</p>"},{"location":"#current-development","title":"Current development","text":"<p>The project is currently on release 3.</p> <p>You can view the source code and contribute by creating a pull request with your modifications or opening an issue.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>The microservice has two instances, an <code>api</code> exposed on the web, where users can send task requests to a queue, and a <code>handler</code>, which listens to the queue and execute the tasks.</p> <p>To run <code>pytasks</code> with all of its dependencies in a testing environment, ensure you have docker and docker compose installed and then run the following command:</p> <pre><code>git clone https://github.com/brenopelegrin/pytasks.git &amp;&amp;\ncd pytasks &amp;&amp;\nexport JWT_PRIVATE_PEM=$(cat ./examples/keys/jwtRS256.key) &amp;&amp;\nexport JWT_PUBLIC_PEM=$(cat ./examples/keys/jwtRS256.key.pub) &amp;&amp;\ndocker compose up -d\n</code></pre> <p> This command uses the example RSA keypair stored in the repository and default passwords for PostgreSQL and RabbitMQ. You MUST setup your own RSA keypair and credentials in production to avoid security issues. See the Setting up section for more informations.</p> <p>After the containers start, the API will be available at <code>http://localhost:8080</code>.</p> <p> For more instructions on how to customize your <code>pytasks</code> containers and how to run them, see Setting up.</p>"},{"location":"#understanding-the-project-with-more-depth","title":"Understanding the project with more depth","text":""},{"location":"#overview","title":"Overview","text":"<p>The project's main goal is to make cloud computing more accessible and facilitate its implementation.</p> <p><code>pytasks</code> provides a complete and customizable backend so that developers only have to worry about developing the tasks, not the backend that runs them.</p> <p>It is based on solid and robust technologies, packages and frameworks. The API is built with Flask and served with gunicorn. The handler is built on top of Celery, enabling it to use various backends for the queue, such as Redis and RabbitMQ and various database backends for storing task results, such as PostgreSQL.</p>"},{"location":"#overview-fluxogram-of-pytasks","title":"Overview fluxogram of pytasks","text":""},{"location":"#what-exactly-is-a-task","title":"What exactly is a task?","text":"<p>Tasks are coded functions that receives arguments and return results, obbeying some specifications. They can be put together in packages (which we call taskpacks) and automatically installed and imported on deploy. The tasks need to have defined arguments with declared types, and the results should be serializable in JSON. </p> <p>For example, the following function can be considered as a task:</p> <pre><code>@celery_app.task\ndef mySimpleTask(number1: int, number2: int):\naddition = number1 + number2\nmultiplication = number1 * number2\nreturn(\n{\n\"addition\": addition,\n\"multiplication\": multiplication\n}\n)\n</code></pre>"},{"location":"#a-little-more-about-the-api","title":"A little more about the api","text":"<p>The API </p> <p>Quick list of endpoints</p> Endpoint Method Description <code>/task/&lt;taskId:uuid&gt;</code> <code>GET</code> Fetch task information <code>/task</code> <code>POST</code> Post a task to server <code>/protected</code> <code>GET</code> Fetch available protected tasks for your JWT token <code>/token</code> <code>GET</code> Generate JWT token from credentials <p> For more detailed information on API endpoints and how to make requests, please see the API specification section.</p>"},{"location":"#a-little-more-about-the-handler","title":"A little more about the handler","text":"<p>The Handler</p>"},{"location":"api/","title":"Nothing here.","text":""},{"location":"api.reference/","title":"api module reference","text":""},{"location":"api.reference/#api.resources.auth.AuthorizedTasks","title":"<code>AuthorizedTasks</code>","text":"<p>Stores the function object of functions decorated by the @authorized_task decorator at self.list.</p> Source code in <code>api/resources/auth.py</code> <pre><code>class AuthorizedTasks:\n\"\"\"\n    Stores the function object of functions decorated by the @authorized_task decorator at self.list.\n    \"\"\"\ndef __init__(self):\nself.list = {}\nself.auth_data = {}\ndef register_task(self, func):\n\"\"\"\n        Registers a function in the AuthorizedTasks.list dict.\n        Args:\n            func (function): the function to be registered.\n        \"\"\"\npure_name = func.name.replace('tasks.packs.', '')\nself.list[pure_name]={\"func\": func}\nself.auth_data[pure_name]={\"func\": func}\n</code></pre>"},{"location":"api.reference/#api.resources.auth.AuthorizedTasks.register_task","title":"<code>register_task(func)</code>","text":"<p>Registers a function in the AuthorizedTasks.list dict.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function</code> <p>the function to be registered.</p> required Source code in <code>api/resources/auth.py</code> <pre><code>def register_task(self, func):\n\"\"\"\n    Registers a function in the AuthorizedTasks.list dict.\n    Args:\n        func (function): the function to be registered.\n    \"\"\"\npure_name = func.name.replace('tasks.packs.', '')\nself.list[pure_name]={\"func\": func}\nself.auth_data[pure_name]={\"func\": func}\n</code></pre>"},{"location":"api.reference/#api.resources.auth.authorized_task","title":"<code>authorized_task(task_func)</code>","text":"<p>Decorator for functions which require authentication by JWT. When the @authorized_task is placed, it will register the decorated function in the AuthorizedTasks function list.</p> <p>Parameters:</p> Name Type Description Default <code>task_func</code> <code>function</code> <p>the decorated function</p> required <p>Returns:</p> Name Type Description <code>wrapper</code> <p>a function that returns the original task_func function.</p> Source code in <code>api/resources/auth.py</code> <pre><code>def authorized_task(task_func):\n\"\"\"\n    Decorator for functions which require authentication by JWT.\n    When the @authorized_task is placed, it will register the decorated function in the AuthorizedTasks function list.\n    Args:\n        task_func (function): the decorated function\n    Returns:\n        wrapper: a function that returns the original task_func function.\n    \"\"\"\npure_name = task_func.name.replace('tasks.packs.', '')\nif task_func not in authorizedTasks.list:\nlogger.info(f\"[auth] task '{pure_name}' registered as authorized\")\nauthorizedTasks.register_task(task_func)\ndef wrapper(*args, **kwargs):\nreturn task_func(*args, **kwargs)\nreturn wrapper\n</code></pre>"},{"location":"api.reference/#api.resources.auth.generate_new_jwt","title":"<code>generate_new_jwt(payload)</code>","text":"<p>Generates a new JWT token containing a payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>A dictionary with the data that will be placed inside the JWT token.</p> required <p>Returns:</p> Name Type Description <code>jwt_token</code> <code>str</code> <p>the generated JWT token</p> Source code in <code>api/resources/auth.py</code> <pre><code>def generate_new_jwt(payload: dict):\n\"\"\"\n    Generates a new JWT token containing a payload.\n    Args:\n        payload (dict): A dictionary with the data that will be placed inside the JWT token.\n    Returns:\n        jwt_token (str): the generated JWT token\n    \"\"\"\nif use_jwt_expire:\nif 'exp' not in payload:\nmax_timestamp = str(calendar.timegm(datetime.now(tz=timezone.utc).timetuple())+jwt_expire_time_sec)\npayload['exp'] = max_timestamp\nreturn(jwt.encode(payload, jwt_private_pem, algorithm=jwt_algorithm), payload['exp'])\nelse:\nreturn(jwt.encode(payload, jwt_private_pem, algorithm=jwt_algorithm), str(payload['exp']))\nelse:\nreturn(jwt.encode(payload, jwt_private_pem, algorithm=jwt_algorithm), 'infinity')\n</code></pre>"},{"location":"api.reference/#api.resources.auth.get_user_permissions","title":"<code>get_user_permissions(user, password)</code>","text":"<p>Gets user allowed task names by credentials passed. It's possible to customize this function for the needs of your project. We discourage to use hardcoded values for credentials or permissions here. It is strongly recommended to hash your credentials with bcrypt and store them in a database. By default, all users have test.main.myProtectedTask as an allowed task.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>user identifier credential</p> required <code>password</code> <code>str</code> <p>password credential</p> required <p>Returns:</p> Name Type Description <code>payload</code> <code>dict</code> <p>dictionary with user's allowed tasks.</p> Source code in <code>api/resources/auth.py</code> <pre><code>def get_user_permissions(user:str, password:str):\n\"\"\"\n    Gets user allowed task names by credentials passed.\n    It's possible to customize this function for the needs of your project.\n    We discourage to use hardcoded values for credentials or permissions here.\n    It is strongly recommended to hash your credentials with bcrypt and store them in a database.\n    By default, all users have test.main.myProtectedTask as an allowed task.\n    Args:\n        user (str): user identifier credential\n        password (str): password credential\n    Returns:\n        payload (dict): dictionary with user's allowed tasks.\n    \"\"\"\n# You can implement here an algorithm to get a dictionary from database based on credentials.\npayload = {\n\"allowed_tasks\": {\n\"test.main.myProtectedTask\": True\n}\n}\nreturn payload\n</code></pre>"},{"location":"api.reference/#api.resources.auth.verify_credentials","title":"<code>verify_credentials(user, password)</code>","text":"<p>A function that verifies if the credentials are correct. It's possible to customize this function for the needs of your project. We discourage to use hardcoded values for credentials here. It is strongly recommended to hash your credentials with bcrypt and store them in a database. By default, the correct credentials are user=\"testuser\" and password=\"testpass\"</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>user identifier credential</p> required <code>password</code> <code>str</code> <p>password credential</p> required <p>Returns:</p> Name Type Description <code>isVerified</code> <code>boolean</code> <p>true if credentials are correct, otherwise, false.</p> Source code in <code>api/resources/auth.py</code> <pre><code>def verify_credentials(user:str, password:str):\n\"\"\"\n    A function that verifies if the credentials are correct.\n    It's possible to customize this function for the needs of your project.\n    We discourage to use hardcoded values for credentials here.\n    It is strongly recommended to hash your credentials with bcrypt and store them in a database.\n    By default, the correct credentials are user=\"testuser\" and password=\"testpass\"\n    Args:\n        user (str): user identifier credential\n        password (str): password credential\n    Returns:\n        isVerified (boolean): true if credentials are correct, otherwise, false.\n    \"\"\"\n# You can implement here an algorithm to verify the credentials, e.g. verifying a bcrypt hash on database\nif user == \"testuser\" and password == \"testpass\":\nreturn True\nelse:\nreturn False\n</code></pre>"},{"location":"api.reference/#api.resources.web.NewTask","title":"<code>NewTask</code>","text":"<p>         Bases: <code>Resource</code></p> <p>Registers a new task request through POST method.</p> Source code in <code>api/resources/web.py</code> <pre><code>class NewTask(Resource):\n\"\"\"\n    Registers a new task request through POST method.\n    \"\"\"\ndef post(self):\n\"\"\"Posts a task \n        Returns:\n            taskInfo (dict): dictionary with the task id, arguments passed and current status of the task. \n        \"\"\"\nparser = reqparse.RequestParser()\nparser.add_argument('type', required=True, type=str, help='You need to inform type', location='json')\nparser.add_argument('args', required=True, type=dict, help='You need to inform args dict', location='json')\nparser.add_argument('Authorization', location='headers')\nargs = parser.parse_args()\nabort_if_tasktype_doesnt_exist(tasktype=args[\"type\"])\nabort_if_doesnt_have_permission(tasktype=args[\"type\"], auth_header=args[\"Authorization\"])\nabort_if_task_params_are_invalid(tasktype=args[\"type\"], given_params=args[\"args\"])\ntry:\ntask_class = tasklist[args[\"type\"]]['task']\ntask = task_class.delay(**args[\"args\"])\nreturn {\"id\": task.id, \"type\": args[\"type\"], \"status\": task.state}\nexcept Exception as exc:\nreturn{\"error\": str(exc)}\n</code></pre>"},{"location":"api.reference/#api.resources.web.NewTask.post","title":"<code>post()</code>","text":"<p>Posts a task </p> <p>Returns:</p> Name Type Description <code>taskInfo</code> <code>dict</code> <p>dictionary with the task id, arguments passed and current status of the task.</p> Source code in <code>api/resources/web.py</code> <pre><code>def post(self):\n\"\"\"Posts a task \n    Returns:\n        taskInfo (dict): dictionary with the task id, arguments passed and current status of the task. \n    \"\"\"\nparser = reqparse.RequestParser()\nparser.add_argument('type', required=True, type=str, help='You need to inform type', location='json')\nparser.add_argument('args', required=True, type=dict, help='You need to inform args dict', location='json')\nparser.add_argument('Authorization', location='headers')\nargs = parser.parse_args()\nabort_if_tasktype_doesnt_exist(tasktype=args[\"type\"])\nabort_if_doesnt_have_permission(tasktype=args[\"type\"], auth_header=args[\"Authorization\"])\nabort_if_task_params_are_invalid(tasktype=args[\"type\"], given_params=args[\"args\"])\ntry:\ntask_class = tasklist[args[\"type\"]]['task']\ntask = task_class.delay(**args[\"args\"])\nreturn {\"id\": task.id, \"type\": args[\"type\"], \"status\": task.state}\nexcept Exception as exc:\nreturn{\"error\": str(exc)}\n</code></pre>"},{"location":"api.specification/","title":"API specification","text":""},{"location":"handler/","title":"Nothing here.","text":""},{"location":"project.contributing/","title":"How to contribute","text":"<p>You can view the source code and contribute by creating a pull request with your modifications or opening an issue.</p>"},{"location":"release2-doc/","title":"flask-tasks-docker","text":"<p>This is a generic ready-to-run Flask RESTful API written in Python that can receive task requests with some arguments, run some logic with the arguments provided (using Celery and AMQP queues) and store the results on a SQL database. The results can then be retrieved from the API. The processing instances can be scaled according to your needs using docker.</p>"},{"location":"release2-doc/#main-features","title":"Main features","text":"<ul> <li>You can scale multiple workers that can proccess tasks in parallel</li> <li>You can add as many custom tasks as you want: highly customizable</li> <li>Can receive tasks from <code>POST</code> requests passing multiple parameters in <code>json</code></li> <li>Can store the result of the tasks in a SQL database</li> <li>Can return the result of a task from <code>GET</code> requests passing the task ID as parameter</li> </ul>"},{"location":"release2-doc/#current-development","title":"Current development","text":"<p>The project is currently on release 2.0.</p> <p> Features/changes made on release 2.0: - Project redesigned to manage the tasks using Celery + RabbitMQ + PostgreSQL - Added authentication by JWT - Removed Janitor, now RabbitMQ + Celery manages the completed tasks.</p> <p> Upcoming features/changes on release 3.0: - Packaging system for tasks - Isolated environment for each task - C/C++ wrapper for tasks written in C/C++</p>"},{"location":"release2-doc/#getting-started","title":"Getting started","text":"<ul> <li> <p>In what applications should I use it?</p> <p>You should use the <code>flask-tasks</code> when you need a server to do some computation based on received arguments and store the results of the computation for later visualization</p> </li> </ul>"},{"location":"release2-doc/#setting-up-and-running","title":"Setting up and running","text":"<p>First, make sure you have <code>docker</code>and <code>docker compose</code> installed.</p> <p> Before running, please make sure to configure the environment variables for API and Handler.</p> <p>To run the API docker container, use the following command. <pre><code>docker run --network=host brenopelegrin/flask-tasks-api:latest\n</code></pre></p> <p>To run the worker container, use the following command. You will need to have <code>uuidgen</code> to generate a unique worker name.</p> <pre><code>docker run --network=host --env WORKER_NAME=`uuidgen` brenopelegrin/flask-tasks-handler:latest\n</code></pre> <p>If you want to specify a custom worker name, change the <code>WORKER_NAME</code> variable. Make sure that all workers have unique names.</p>"},{"location":"release2-doc/#configuring-environment-variables","title":"Configuring environment variables","text":"<ul> <li>API:</li> </ul> <p>Please set the SQL Database URL, the AMQP backend URL, and the number of gunicorn workers and threads you want. </p> <p>If you want to, you can allow CORS only for your front-end site by setting the FRONTEND_URL with the front-end URL.</p> <p>You need to generate a 256 RSA keypair to use authentication based on JWT tokens.</p> <pre><code>ENV DATABASE_URL postgres://postgres:123@localhost:5432/flask_tasks_v2\nENV AMQP_URL redis://localhost:6379\nENV FRONTEND_URL *\nENV GUNICORN_WORKERS 3\nENV GUNICORN_THREADS 1\nENV JWT_PUBLIC_PEM \"&lt;Your public RSA 256 key here&gt;\"\nENV JWT_PRIVATE_PEM \"&lt;Your public RSA 256 key here&gt;\"\n</code></pre> <p>To generate the 256 RSA keypar, you can run the following (make sure to have openssl installed):</p> <pre><code>openssl genrsa -out private.pem 2048 &amp;&amp; openssl rsa -in private.pem -pubout -out public.pem\n</code></pre> <p>Then, set the environment variables with your keys.</p> <ul> <li>Handler:</li> </ul> <p>Please set the SQL Database URL, the AMQP backend URL and the worker name you want. Make sure the worker name is unique.</p> <pre><code>ENV DATABASE_URL postgres://postgres:123@localhost:5432/flask_tasks_v2\nENV AMQP_URL redis://localhost:6379\nENV WORKER_NAME worker\n</code></pre>"},{"location":"release2-doc/#api-endpoints","title":"API endpoints","text":""},{"location":"release2-doc/#tasknew","title":"/task/new","text":"<p>Method: <code>POST</code></p> <p>This endpoint will register a new task in the server. You need to pass some required arguments inside a <code>application/json</code>. The json should contain a string with the task type, named <code>type</code> and the task-specific required arguments as a dictionary, named <code>args</code>:</p> <p>Example of request (task of type \"add\"):</p> <p>Parameters: <pre><code>{\n\"type\":\"add\",\n\"args\": {\n\"x\": 1,\n\"y\": 2\n}\n}\n</code></pre></p> <pre><code>curl -X POST localhost:5000/task/new -H 'Content-Type: application/json' -d '{\"type\":\"add\", \"args\":{\"x\": 1, \"y\": 2}}'\n</code></pre> <p>Example of response:</p> <pre><code>{\n\"id\": \"5861c3a8-fa0f-4b84-9e54-04b545408114\",\n\"result\": {},\n\"args\": {\"x\": 1, \"y\": 2},\n\"status\": \"PENDING\",\n\"type\": \"add\",\n}\n</code></pre> <p>If the task type passed doesn't match the name of any function declared in the <code>api/tasks.py</code> file, then it will return an error:</p> <pre><code>{\n\"message\":\"task type [tasktype] doesnt exist\"\n}\n</code></pre> <p>If the task exists but you didn't pass an required argument of the declared function, then it will return an error:</p> <pre><code>{\n\"message\": \"the required param [param] was not passed.\"\n}\n</code></pre> <p>If the task exists, all arguments were passed but the type of an argument doesn't match the type of the argument on the declared function, then it will return an error:</p> <pre><code>{\n\"message\": \"the passed param [param] doesnt match the required type: [required type].\"\n}\n</code></pre> <p>If you pass an argument that is not required, then it will return an error:</p> <pre><code>{\n\"message\": \"the passed param [param] is not required.\"\n}\n</code></pre> <p>You can also use the example task \"mov3d\" for testing purposes, which will simulate the trajectory of a particle:</p> <p>Parameters: <pre><code>{\n\"type\":\"mov3d\",\n\"args\": {\n\"dt\": 0.001,\n\"mass\": 1.0,\n\"r0\": [0.5, 0.5, 0.5],\n\"v0\": [10.0, 10.0, 10.0],\n\"radius\": 0.3,\n\"drag\": false\n}\n}\n</code></pre></p> <p>Example of response:</p> <p><pre><code>{\n\"id\": \"5861c348-fa0f-4b84-9e54-04b545408114\",\n\"result\": {[all results of simulation]},\n\"args\": {[args you passed]},\n\"status\": \"SUCCESS\",\n\"type\": \"mov3d\",\n}\n</code></pre> Where the \"result\" will contain the following: <pre><code>\"result\": {\n\"r\": [[x1,y1,z1], [x2,y2,z2], [xn,yn,zn]],\n\"v\": [[x1,y1,z1], [x2,y2,z2], [xn,yn,zn]],\n\"a\": [[x1,y1,z1], [x2,y2,z2], [xn,yn,zn]],\n\"alpha\": [[x1,y1,z1], [x2,y2,z2], [xn,yn,zn]],\n\"w\": [[x1,y1,z1], [x2,y2,z2], [xn,yn,zn]],\n\"t\": [t1, t2, tn]\n}\n</code></pre></p>"},{"location":"release2-doc/#tasktask_idview","title":"/task/<code>&lt;task_id&gt;</code>/view","text":"<p>Method: <code>GET</code></p> <p>This endpoint will return the current data for the task with id <code>task_id</code> in <code>application/json</code> format:</p> <p>Example of request:</p> <p>Parameters: <code>&lt;task_id&gt;</code></p> <pre><code>curl -X GET localhost:5000/task/5861c3a8-fa0f-4b84-9e54-04b545408114/view\n</code></pre> <p>Example of response:</p> <pre><code>{\n\"id\": \"5861c3a8-fa0f-4b84-9e54-04b545408114\",\n\"result\": 3,\n\"args\": {\"x\": 1, \"y\": 2},\n\"status\": \"SUCCESS\",\n\"type\": \"add\",\n}\n</code></pre> <p>The status of a retrieved task can be: - <code>PENDING</code></p> <p>Means that the task doesn't exist OR exists and has not yet been received by a worker.</p> <ul> <li><code>STARTED</code></li> </ul> <p>Means that the task has been received by a worker and is actually being computed</p> <ul> <li><code>SUCCESS</code></li> </ul> <p>Means that the task has been received by a worker, have already been computed and is available for view</p>"},{"location":"release2-doc/#the-handler","title":"The <code>handler</code>","text":"<p>The handler is a module of the system based on Celery that will subscribe to the AMQP queue and wait for new tasks. When it receives a task, it will execute the task and store its value on the SQL database. </p> <p>You can add as many tasks as you want in the code, by adding the decorator <code>@app.task</code> on top of a function in the <code>handler\\tasks.py</code> file. Then, the function name will become a new task type and can be called from the API. For example, if you want to add a task that adds two numbers x and y, you should write the following:</p> <pre><code>@app.tasks\ndef add(x:int, y:int):\nreturn x+y\n</code></pre> <p>It is required to explicitly declare the function arguments with annotations so that the API can process them correctly.</p> <p>The handler will mark the current task row as locked in the database, so that the other instances of handlers can't edit at the same time.</p> <p>\u26a0\ufe0f In order for all tasks processed by the API to be able to run on all handler instances, both the API and Handler <code>tasks.py</code> file must be EXACTLY the same. </p> <p>If you want some handler instances to run only specific tasks, see the <code>Customizing handler instances for specific tasks</code> section.</p>"},{"location":"release2-doc/#customizing-handler-instances-for-specific-tasks","title":"Customizing handler instances for specific tasks","text":"<p>A handler instance will only run the tasks that have been declared on the <code>handler/tasks.py</code>. </p> <p>If you want some tasks to run in a specific handler instance, then you should copy the source <code>handler</code> directory to directories with different names for each handler instance type you want:</p> <pre><code>mkdir handler-type1\nmkdir handler-type2\ncp -r handler handler-type1\ncp -r handler handler-type2\n</code></pre> <p>Then, you can edit each <code>handler-typeX/tasks.py</code> file and add specific tasks to each handler.</p> <p>After that, you can customize your <code>docker-compose.yml</code> file to scale your different handler instance types:</p> <pre><code>version: \"3\"\nservices:\napi:\nbuild: ./api\nports:\n- \"8000:8080\"\nnetwork_mode: \"host\"\nenvironment:\nDATABASE_URL: \"postgres://postgres:123@localhost:5432/flask_tasks\" handler-type1:\nbuild: ./handler-type1\nnetwork_mode: \"host\"\nenvironment:\nWORKER_NAME: \"worker2\"\nAMQP_URL: \"redis://localhost:6379\"\nDATABASE_URL: \"postgres://postgres:123@localhost:5432/flask_tasks\"\nhandler-type2:\nbuild: ./handler-type2\nnetwork_mode: \"host\"\nenvironment:\nWORKER_NAME: \"worker2\"\nAMQP_URL: \"redis://localhost:6379\"\nDATABASE_URL: \"postgres://postgres:123@localhost:5432/flask_tasks\"\n</code></pre> <p>To deploy, run the docker compose build command <pre><code>docker compose build --no-cache --pull\n</code></pre></p> <p>Then, run the docker compose up command:</p> <pre><code>docker compose up\n</code></pre>"},{"location":"setup/","title":"Setting up pytasks","text":"<p>First, you should clone the repository and go to the cloned repository:</p> <pre><code>git clone https://github.com/brenopelegrin/pytasks.git &amp;&amp;\ncd pytasks &amp;&amp; export PYTASKS_DIR=$(pwd)\n</code></pre>"},{"location":"setup/#configuring-api","title":"Configuring <code>api</code>","text":""},{"location":"setup/#generating-your-rsa-keys-for-api-authentication","title":"Generating your RSA keys for API authentication","text":"<p>Make sure you have <code>ssh-keygen</code> and <code>openssl</code> installed. Then, run the following command to generate 4096-bit RSA public and private keypair for API:</p> <pre><code>cd $PYTASKS_DIR &amp;&amp; mkdir keys &amp;&amp; cd keys &amp;&amp;\nssh-keygen -t rsa -b 4096 -m PEM -f jwtRS256.key &amp;&amp;\nopenssl rsa -in jwtRS256.key -pubout -outform PEM -out jwtRS256.key.pub\n</code></pre> <p>After that, your keys will be available inside the <code>pytasks/keys/</code> directory. The private key is <code>jwtRS256.key</code> and the public key is <code>jwtRS256.key.pub</code>.</p>"},{"location":"setup/#setting-up-environment-variables-for-api","title":"Setting up environment variables for API","text":""},{"location":"setup/#using-env-file-recommended","title":"Using .env file (recommended)","text":"<p>For this, you can modify the <code>pytasks/api.env</code> file and configure your env variables in the format <code>KEY=VALUE</code>.</p> <p>For example:</p> api.env<pre><code>DATABASE_URL=postgres://user:password@ip:5432/pytasks\nAMQP_URL=amqp://user:password@ip:5672\nFRONTEND_URL=*\nGUNICORN_WORKERS=3\nGUNICORN_THREADS=1\nUSE_JWT_EXPIRE=true\nJWT_EXPIRE_SEC=3600\nJWT_PRIVATE_PEM=[your private PEM here]\nJWT_PUBLIC_PEM=[your public PEM here]\n</code></pre> Key Description DATABASE_URL The SQL database connection URI FRONTEND_URL The accepted URL for CORS (* means accept all) GUNICORN_WORKERS How many workers you want for gunicorn GUNICORN_THREADS How many threads you want for gunicorn USE_JWT_EXPIRE If true, JWT tokens will expire in JWT_EXPIRE_SEC seconds after creation JWT_EXPIRE_SEC Time, in seconds, for the JWT tokens to expire JWT_PRIVATE_PEM RSA private key for JWT signing JWT_PUBLIC_PEM RSA public key to verify JWT signature"},{"location":"setup/#setting-manually-on-dockerfile","title":"Setting manually on Dockerfile","text":"<p>For this, you can modify the <code>pytasks/api/Dockerfile</code> file and configure your env variables in the format <code>ENV KEY=VALUE</code>.</p> <p>For example:</p> api/Dockerfile<pre><code>FROM python:3.10-slim-bullseye\nCOPY . /app\nENV DATABASE_URL=postgres://user:password@ip:5432/pytasks\nENV AMQP_URL=amqp://user:password@ip:5672\nENV FRONTEND_URL=*\nENV GUNICORN_WORKERS=3\nENV GUNICORN_THREADS=1\nENV USE_JWT_EXPIRE=true\nENV JWT_EXPIRE_SEC=3600\nENV JWT_PRIVATE_PEM=[your private PEM here]\nENV JWT_PUBLIC_PEM=[your public PEM here]\nEXPOSE 8080\nRUN pip install --no-cache-dir -r /app/requirements.txt\nRUN python /app/tasks/manager/manager.py -i physicsjs test --api /app\nWORKDIR /app\nENTRYPOINT gunicorn --conf /app/gunicorn.conf.py app:app\n</code></pre>"},{"location":"setup/#setting-manually-on-docker-composeyml","title":"Setting manually on docker-compose.yml","text":"<p>For this, you can modify the <code>pytasks/docker-compose.yml</code> file and configure your env variables in the API service declaration.</p> <p>For example:</p> <pre><code>services:\napi:\nimage: brenopelegrin/pytasks-api:latest\nports:\n- \"8080:8080\"\nnetworks:\n- pytasks-network\nenvironment:\n- DATABASE_URL: postgres://user:password@ip:5432/pytasks\n- AMQP_URL: amqp://user:password@ip:5672\n- FRONTEND_URL: *\n- GUNICORN_WORKERS: 3\n- GUNICORN_THREADS: 1\n- USE_JWT_EXPIRE: true\n- JWT_EXPIRE_SEC: 3600\n- JWT_PRIVATE_PEM: 'your private PEM here'\n- JWT_PUBLIC_PEM: 'your public PEM here'\n</code></pre>"},{"location":"setup/#configuring-handler","title":"Configuring <code>handler</code>","text":""},{"location":"taskpacks.howtocreate/","title":"Creating your own taskpack","text":"<p>Taskpacks are collection of Celery tasks packaged inside a python module with some specifications:</p> <ul> <li>All tasks functions must be declarated inside the <code>init()</code> function on the taskpack's <code>main.py</code>.</li> <li>All tasks must have annotated arguments: each variable received by the task must have a fixed type (<code>int</code>, <code>str</code>, <code>float</code>, others...).</li> <li>External resources used by the tasks must be located in Python files inside the taskpack's <code>resources</code> directory.</li> <li>All tasks outputs must be in a <code>JSON</code> seriallizable format.</li> </ul>"},{"location":"taskpacks.howtocreate/#lets-start-our-project","title":"Let's start our project","text":"<p>An example of valid taskpack that you can use as basis is the pytasks-test taskpack. For this guide, we'll be using it as a basis.</p> <p>First, clone the repository from GitHub and go to its directory:</p> <pre><code>git clone https://github.com/brenopelegrin/pytasks-test.git &amp;&amp; cd pytasks-test\n</code></pre> <p>Then, you'll see some files in the parent directory:</p> Name Description main.py Where the <code>init()</code> function is located. Declare your tasks inside the function. __init__.py Initialization code used by pytasks to get tasks working. Do not modify it. package.json Information about the package: author, name, version, etc. requirements.txt The package dependencies to be installed with pip."},{"location":"taskpacks.howtocreate/#understanding-and-modifying-mainpy","title":"Understanding and modifying main.py","text":"<p>The <code>main.py</code> file contains the following: main.py<pre><code>def init(celery_app, **global_decorators):\nauthorized_task = global_decorators['authorized_task']\n@celery_app.task\ndef add(x: int, y: int):\nreturn x + y\n@celery_app.task\ndef subtract(x: int, y: int):\nreturn x-y\n@celery_app.task\ndef hypot(x: float, y: float):\nfrom .resources import example_resource as myResource\nreturn(myResource.hypot(x, y))\n@authorized_task\n@celery_app.task\ndef myProtectedTask(x: int, y: int):\nreturn x+y\n</code></pre></p>"},{"location":"taskpacks.howtocreate/#tasks-inside-mainpy","title":"Tasks inside main.py","text":"<p>The <code>init()</code> function receives the <code>celery_app</code> decorator and <code>global_decorators</code> from pytasks. By using <code>@celery_app.task</code> on top of a function, you create a task. As you can see, every task must have type annotation on its parameters.</p> <p> Great task with annotations <pre><code>@celery_app.task\ndef add(x: int, y: int):\nreturn x + y\n</code></pre></p> <p> Wrong task without annotations <pre><code>@celery_app.task\ndef add(x, y):\nreturn x + y\n</code></pre></p> <p>By default, pytasks passes the <code>authorized_task</code> decorator inside the <code>global_decorators</code> object. By using <code>@authorized_task</code> on top of a valid task, pytasks will require authentication for the task to run.</p> <p> Note: for compatibility reasons, you need to declare a variable to unpack the desired decorator inside <code>global_decorators</code>. Do NOT use <code>@global_decorators['authorized_task']</code> directly. See the following example.</p> <p>To use the <code>authorized_task</code> decorator, you can do:</p> <pre><code>def init(celery_app, **global_decorators):\nauthorized_task = global_decorators['authorized_task']\n@authorized_task\n@celery_app.task\ndef someProtectedTask(user: str, password: str):\nreturn({\"authenticated\": True})\n</code></pre> <p> Note: you should ALWAYS use global decorators ON TOP of <code>@celery_app.task</code>.</p>"},{"location":"taskpacks.howtocreate/#using-external-resources-inside-your-tasks","title":"Using external resources inside your tasks","text":"<p>You can put python files inside the <code>resources/</code> directory. All python files inside this directory can be imported inside your tasks as a module.</p> <p>For example, see the <code>resources/example_resource.py</code> file:</p> resources/example_resource.py<pre><code>def hypot(a, b):\nreturn(((a**2) + (b**2))**(1/2))\n</code></pre> <p>This resource is used inside <code>main.py</code>'s <code>hypot</code> task. See: main.py<pre><code>def init(celery_app, **global_decorators):\n@celery_app.task\ndef hypot(x: float, y: float):\nfrom .resources import example_resource as myResource\nreturn(myResource.hypot(x, y))\n</code></pre></p>"},{"location":"taskpacks.howtocreate/#best-practices-for-resources","title":"Best practices for resources:","text":"<p>Taskpacks resources are modules, so you need to follow some best practices for modules:</p> <ul> <li>Do not declare variables in global scope. Only declare classes and functions.</li> <li>Use meaningful names for your functions and classes.</li> <li>Do not import other modules inside your resources. Instead, import them directly in the task.</li> </ul>"},{"location":"taskpacks.howtocreate/#modifying-packagejson","title":"Modifying package.json","text":"<p>The <code>package.json</code> file contain information about you and your taskpack. There, you can declare the taskpack version, its author, name, description and license.</p> <p>For example:</p> package.json<pre><code>{\n\"name\": \"test\",\n\"author\": \"brenopelegrin\",\n\"version\": \"1.0\",\n\"description\": \"A test package to demonstrate pytasks usage.\",\n\"license\": \"MIT\"\n}\n</code></pre>"},{"location":"taskpacks.howtocreate/#submitting-your-taskpack-to-the-official-repository","title":"Submitting your taskpack to the official repository","text":"<p>To submit your taskpack to the official pytasks taskpack repository, first push your taskpack directory to a GitHub repository. </p> <p>Then, please open an issue on pytasks repository. In your issue, answer the following:</p> <ul> <li>Taskpack name</li> <li>Taskpack short description: main features, purpose and target audience</li> <li>All taskpack dependencies</li> <li>Taskpack GitHub repository URL </li> </ul> <p>After some time, your issue will be read and we will decide on including your taskpack in the official repository.</p>"},{"location":"taskpacks.manager.manager.reference/","title":"Taskpacks manager reference","text":""},{"location":"taskpacks.manager.manager.reference/#taskpacks.manager.manager.install","title":"<code>install(packages, context, console)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>_type_</code> <p>description</p> required <code>context</code> <code>_type_</code> <p>description</p> required <code>console</code> <code>_type_</code> <p>description</p> required Source code in <code>taskpacks/manager/manager.py</code> <pre><code>def install(packages, context, console):\n\"\"\"_summary_\n    Args:\n        packages (_type_): _description_\n        context (_type_): _description_\n        console (_type_): _description_\n    \"\"\"\nif(packages != []):\nconsole.print(\"[bold white]Installing the following packages: \")\n[console.print(f\"\\t[italic green](+) {x}\") for x in packages]\nif(context['handler']['dir']):\ninstallDependencies = False\nextractedPackages = []\nhandlerDir = \"\"\nfor package in packages:\nif(package in context[\"officialPackagesManifest\"]):\nconsole.print(f\"[bold white](wheel/handler/install) donwloading package [bold green]'{package}'\")\npackageUrl = context[\"officialPackagesManifest\"][package]['link']\nhandlerDir = context['handler']['dir']\nif(os.path.isdir(handlerDir)):\nos.chdir(handlerDir)\npackageInstallDir = os.path.join(handlerDir, f'tasks/packs/{package}')\nif(os.path.isdir(packageInstallDir)):\nos.system(f'rm -rf {packageInstallDir}')\nelse:\nos.mkdir(packageInstallDir)\nif package not in extractedPackages:\nwith urlopen(packageUrl) as zipresp:\nconsole.print(f\"[bold white](wheel/handler/install) extracting package [bold green]'{package}'\")\nwith ZipFile(BytesIO(zipresp.read())) as zfile:\nzip_parent_dir = zfile.infolist()[0].filename\nzip_infos = zfile.infolist()\nzip_infos.pop(0)\nfor zip_info in zip_infos:\nzip_info.filename = zip_info.filename.replace(zip_parent_dir, '')\nzfile.extract(zip_info, path=packageInstallDir)\nconsole.print(f\"[bold white](wheel/handler/install) extracted package [bold green]'{package}'\")\nextractedPackages.append(package)\ninstallDependencies = True\nelse:\nconsole.print(f\"[bold red]:warning: (wheel/handler/install) package '{package}' not found on official packages manifest.\")\nconsole.print(f\"[bold white](wheel/handler/install) installing dependencies for extracted packages [bold green]{extractedPackages}\\n\")\nos.chdir(handlerDir)\nif(os.path.isfile(os.path.join(handlerDir, 'tasks/install_packs.py'))):\nos.system('python tasks/install_packs.py')\nconsole.print(f\"\\n[bold white](wheel/handler/install) installed dependencies for extracted packages [bold green]{extractedPackages}\")\nelse:\nconsole.print(f\"\\n[bold red]:warning: (wheel/handler/install) couldn't install dependencies for extracted packages [bold green]{extractedPackages}: [bold white] install_packs.py not found on handler/tasks/packs.\")\nconsole.print(f\"\\n[bold white](wheel/handler/install) finished.\\n\")\nelse:\nconsole.print(\":warning: (wheel/handler/install) Argument --handler was not passed. No changes will be made on handler directory.\")\nif(context['api']['dir']):\ninstallDependencies = False\nextractedPackages = []\napiDir = \"\"\nfor package in packages:\nif(package in context[\"officialPackagesManifest\"]):\nconsole.print(f\"[bold white](wheel/api/install) donwloading package [bold green]'{package}'\")\npackageUrl = context[\"officialPackagesManifest\"][package]['link']\napiDir = context['api']['dir']\nif(os.path.isdir(apiDir)):\nos.chdir(apiDir)\npackageInstallDir = os.path.join(apiDir, f'tasks/packs/{package}')\nif(os.path.isdir(packageInstallDir)):\nos.system(f'rm -rf {packageInstallDir}')\nelse:\nos.mkdir(packageInstallDir)\nif package not in extractedPackages:\nwith urlopen(packageUrl) as zipresp:\nconsole.print(f\"[bold white](wheel/api/install) extracting package [bold green]'{package}'\")\nwith ZipFile(BytesIO(zipresp.read())) as zfile:\nzip_parent_dir = zfile.infolist()[0].filename\nzip_infos = zfile.infolist()\nzip_infos.pop(0)\nfor zip_info in zip_infos:\nzip_info.filename = zip_info.filename.replace(zip_parent_dir, '')\nzfile.extract(zip_info, path=packageInstallDir)\nconsole.print(f\"[bold white](wheel/api/install) extracted package [bold green]'{package}'\")\nextractedPackages.append(package)\ninstallDependencies = True\nelse:\nconsole.print(f\"[bold red]:warning: (wheel/api/install) package '{package}' not found on official packages manifest.\")\nconsole.print(f\"[bold white](wheel/api/install) installing dependencies for extracted packages [bold green]{extractedPackages}\\n\")\nos.chdir(apiDir)\nif(os.path.isfile(os.path.join(apiDir, 'tasks/install_packs.py'))):\nos.system('python tasks/install_packs.py')\nconsole.print(f\"\\n[bold white](wheel/api/install) installed dependencies for extracted packages [bold green]{extractedPackages}\")\nelse:\nconsole.print(f\"\\n[bold red]:warning: (wheel/api/install) couldn't install dependencies for extracted packages [bold green]{extractedPackages}: [bold white] install_packs.py not found on api/tasks/packs.\")\nconsole.print(f\"\\n[bold white](wheel/api/install) finished.\\n\")\nelse:\nconsole.print(\":warning: (wheel/api/install) Argument --api was not passed. No changes will be made on api directory.\")\nreturn\n</code></pre>"},{"location":"taskpacks/","title":"Nothing here.","text":""},{"location":"taskpacks.official/","title":"Nothing here.","text":""}]}